<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd" >
<html>
<head>
<meta  http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="author" content="kjell at ieee dot org ">
<meta name="copyright" content="2010">
<meta name="germantranslation" content="heinrich at gailer-net dot de">
<meta name="germancopyright" content="2010, Heinrich Gailer">
<meta name="robots" content="index,follow">
<title>Binary Search</title>
<link rel="stylesheet" type="text/css" href="../CAIstyle.css">
</head>

<body>
<!-- generated by CSSmaker.java, version 04/06/2010 on Wed Jul 06 17:19:38 CEST 2011 -->

<!-- ANSWER DIVISION -->

<div class="answer">
     <div class="topnavigation">
     <a href="ch53B_16.html"><img src="../backIcon.gif" alt="zur vorherigen Seite"></a> &nbsp; 
     <a href="../../index.html#53B"><img src="../homeIcon.gif" alt="zum Inhaltsverzeichnis"></a> &nbsp;
     <a href="ch53B_18.html"><img src="../nextIcon.gif" alt="zur n&auml;chsten Seite"></a>
     </div>
<h3>Anwort:</h3>
<p>
No. Linear search can be used to look through the entries one-by-one
starting with the first entry (see chapter 49B).
</p>


</div>

<!-- LESSON DIVISION -->
<div class="lesson">
<h1>Binary Search</h1>


<a name="binary search"></a>

<p>
Linear search is slow. Just think of using it by hand with a
paper dictionary.
Looking up "zebra" would take a long time if you first had to
inspect every entry that preceded it.
Usually you search for an entry by guessing about where it will be
in the dictionary and then going to that page.
If your guess is correct, you are done.
Otherwise you refine your guess by looking at the page you picked
and deciding if your new guess should go forward or backward.
You can do this because the words are in sorted order.
</p>

<p>
When an array is ordered, an algorithm called
<b>binary search</b> can be used to search for an entry.
This algorithm works about the same way as you do when you
search a dictionary.
The <code>Arrays</code> class has several <code>binarySearch()</code>
methods that can quickly search arrays of primitive types or of object
references.
Let us look at the one that searches an array of object references.
</p>

<blockquote>
<pre>
static int binarySearch( Object[] array, Object key )
</pre>

<p>
Search the array for an object that matches <code>key</code>,
using the <code>compareTo()</code> method.
If the object is found, return the index of the object in the array.
Otherwise, return a negative value R.
</p>

<p>
If the return value R is negative, then (-R) is one cell beyond where
the <code>key</code> would be found if it were in the array.
Use this value to insert a new element into its proper place in the array.
(Move elements at (-R) and above to make room.)
</p>

<p>
If (-R) equals the size of the array, then the <code>key</code> is not
in the array, and it should go at the very end, but there is no room.
</p>
</blockquote>

<p>
For now, let us use binary search for searching
and not insert new entries into the array.
</p>


        <div class="clearfloats">  <!-- divs need something inside of them --> </div>
</div> <!-- end lesson -->

<!-- QUESTION DIVISION -->
<div class="question">
<h3> FRAGE 17:</h3>
<p>
With a dictionary of just 10 entries, does it make much difference
how fast searching is?
</p>

     <div class="navigation">
     <a href="ch53B_16.html"><img src="../backIcon.gif" alt="zur vorherigen Seite"></a> &nbsp; 
     <a href="../../index.html#53B"><img src="../homeIcon.gif" alt="zum Inhaltsverzeichnis"></a> &nbsp;
     <a href="ch53B_18.html"><img src="../nextIcon.gif" alt="zur n&auml;chsten Seite"></a>
     </div>
</div>

</body>
</html>
